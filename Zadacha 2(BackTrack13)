//Задача вывода путника из лабиринта. Дан лабиринт размером NхN (N<=15). Форма лабиринта записана в текстовом файле, cтена обозначается символом М, 
//отсутствие стены - символом пробела. Даны координаты мышки в лабиринте (номер строки (X) и номер столбца (Y)) и координаты сыра (номер строки (XС) и 
//номер столбца (YС)). Нужно вывести самый длинный путь мышки к сыру. Для этого распечатать сам лабиринт и обозначить путь символами +. 
//Гарантируется, что такой путь только один. Длина пути определяется числом клеток на которые должна ступить нога мышки.
#include "pt4.h"
#include "fstream"
#include "string"
using namespace std;
int N, k=0, kmax=0;
const int NMAX = 15;
char Lab[NMAX][NMAX];
void go(int x, int y, int XC, int YC, ofstream& f0) {
	if (Lab[x][y] == ' ')
	{
		k++;
		Lab[x][y] = '+';
		if (x == XC && y == YC)
		{
			if (k > kmax) {
				kmax = k;
				for (int i = 0;i < N - 1;i++)
				{
					for (int j = 0;j < N - 1;j++)
						f0 << Lab[i][j];
					f0 << endl;
				}
			}
		}
		else {
			if (x != N - 1)
				go(x + 1, y, XC, YC, f0);
			if (x != 0)
				go(x - 1, y, XC, YC, f0);
			if (y != N - 1)
				go(x, y + 1, XC, YC, f0);
			if (y != 0)
				go(x, y - 1, XC, YC, f0);

		}
		Lab[x][y] = ' ';
		k--;
	}
}
void Solve()
{
	Task("BackTrack13");
	string s, t;
	pt >> s;
	int X, Y, XC, YC, i, j;
	pt >> N >> X >> Y >> XC >> YC;
	pt >> t;
	ifstream f(s);
	ofstream f0(t);
	X--, Y--, XC--, YC--, N++;
	for (i = 0;i < N;i++) {
		f.getline(Lab[i], N);
	}
	go(X, Y, XC, YC, f0);
	f.close();
	f0.close();
}
